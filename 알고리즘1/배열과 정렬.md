# 배열과 정렬

[배열](#배열)

[정렬](#정렬)

[카운팅 정렬](#카운팅-정렬)

[Baby-gin Game](#babygin-game)

[이어지는 숫자 리스트 만들기](#이어지는-숫자-리스트-만들기)

---

## 배열

일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

- 필요성
  
  - 프로그램 내에서 여러 개의 변수가 필요할 때
  - 하나의 선언으로 둘 이상의 변수 선언 가능
  - 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 가능

- **1차원 배열**
  
  - 선언
    - 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성
    - 이름 : 프로그램에서 사용할 배열의 이름 `Arr = list()`, `Arr = [0] * 10 `
  - 접근
    - `Arr[idx] = 20` : 배열 Arr의 idx번 원소에 20을 저장하라

- 최대 값 - 최대 값 문제
  
  ```python
  T = int(input())    # 테스트케이스 개수
  for tc in range(1, T+1):
     N = int(input())
     arr = list(map(int, input().split()))
     max_v = arr[0]
     for i in range(1, N):
         if max_v < arr[i]:
             max_v = arr[i]
     min_v = arr[0]
     for i in range(1, N):
         if min_v > arr[i]:
             min_v = arr[i]
     print(f'#{tc} {max_v - min_v}')
  ```

---

## 정렬

2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값, 혹은 그 반대의 순서대로 재배열하는 것

- 키 : 자료를 정렬하는 기준이 되는 특정 값

- 대표적인 정렬 방식의 종류
  
  - **버블 정렬** : 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
    
    - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
    
    - 시작 복잡도 : O(n^2)
      
      ```python
      def N = 5
      arr = [55, 7, 78, 12, 42]
      
      for i in range(N-1, 0, -1):     # 각 구간의 끝 인덱스 i
          for j in range(i):          # 각 구간에서 두 개씩 비교할 때 왼쪽 원소의 인덱스 j
              if arr[j] > arr[j+1]:   # 왼쪽 원소가 더 크면 교환
                  arr[j], arr[j+1] = arr[j+1], arr[j]
      
      print(*arr)
      ```
  
  - 카운팅 정렬
  
  - 선택 정렬
  
  - 퀵 정렬
  
  - 삽입 정렬
  
  - 병합 정렬

---

## 카운팅 정렬

항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 ㅣ간에 정렬하는 효율적인 알고리즘

- 제한 사항
  
  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
  
  - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함

- 시간 복잡도
  
  - O(n+k) : n은 리스트 길이, k는 정수의 최댓값
1. 개수 세기 n번 n번

2. 누적합 k번 k번

3. 마지막 원소부터 가져옴 n번 n번 n번

```python
DATA = [0, 4, 1, 3, 1, 2, 4, 1]
COUNTS = [0] * 5                    # DATA가 0~4까지의 정수

N = len(DATA)                       # DATA의 크기
TEMP = [0] * N                     # 정렬 결과 저장

# 1단계 : DATA 원소 별 개수 세기
for x in DATA:                      # DATA의 원소 x를 가져와서 COUNTS[x]에 개수 기록
    COUNTS[x] += 1

# 2단계 : 각 숫자까지의 누적 개수 구하기
for i in range(1, 5):               # COUNT[1]~COUNT[4]까지의 누적개수
    COUNTS[i] = COUNTS[i-1] + COUNTS[i]

# 3단계 : DATA의 맨 뒤부터 TEMP에 자리 잡기
for i in range(N-1, -1, -1):
    COUNTS[DATA[i]] -= 1            # 누적개수 1개 감소
    TEMP[COUNTS[DATA[i]]] = DATA[i]

print(*TEMP)                        # 0 1 1 1 2 3 4 4
```

---

## Baby-gin Game

- 설명
  
  - 0~9 사이의 숫자 카드에서 임의의 카드 6장 뽑았을 때
    
    - 3장의 카드가 연속적인 번호면 run
    
    - 3장의 카드가 동일한 번호면 triplet
  
  - 6장의 카드가 run과 triplet로만 구성된 경우 baby-gin

- 방법
  
  - **완전 검색** (Exaustive Search)
    
    - 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인
    
    - Brute-force 혹은 generate-and-test 기법이라고도 불림
    
    - 모든 경우의 수를 테스트한 후, 최종 해법을 도출
    
    - 일반적으로 경우의 수가 상대적으로 작을 때 유용
    
    > 우선 완전 검색으로 접근한여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직
  
  - **순열** (Permutation)
    
    - 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
    
    - 서로 다른 n개 중 r개를 택하는 순열 `nPr`
      
      `nPr = n * (n-1) * (n-2) * ... * (n-r+1)`
    
    > `nPn = n!`이라고 표기하며 Factorial이라고 부름
  
  - **탐욕**(Greedy) 알고리즘
    
    - 최적해를 구하는 데 사용되는 근시안저긴 방법
    
    - 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 구현하면 이렇게 됨
    1. 해 선택
    
    2. 실행 가능성 검사
    
    3. 해 검사
    
    > ex) 거스롬돈 줄이기

---

## 이어지는 숫자 리스트 만들기

- `DATA = list(map(int, input())`

- ```python
  num = 456789
  c = [0] * 12    # 뒤에는 더미
  
  for i in range(6):
      c[num % 10] += 1
      num //= 10
  ```
