# 분할 정복

[분할 정복](#분할-정복)

[병합 정렬](#병합-정렬)

[퀵 정렬](#퀵-정렬)

[이진 검색](#이진-검색)

---

## 분할 정복

문제를 분할해서 해결하는 기법

- 대표적으로 퀵 정렬, 병합 정렬, 이진 검색

- 가짜 동전 찾기 동전
  
  - 반으로 나눠서 저울에 넣기

- 유래 : 1805년 12월 2일 아우스터리츠 전투에서 나폴레옹이 사용한 전략

- 설계 전략 
  
  - **<mark>Top-down approach</mark>**
    
    ![image](https://github.com/user-attachments/assets/d6a81118-d7a4-42a4-8447-a053011703c5)
  
  - 거듭 제곱 : O(log2n)
    
    C ** 8 = (C ** 4) * (C ** 4)

---

## 병합 정렬

여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식

- 활용
  
  - 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과
  
  - top-down 방식
  
  > 나누면 알아서 정복됨

- 시간 복잡도 : O(n log n)
  
  - 분할 단계는 log n번 일어남
  
  - 각 단계에서 모든 원소를 비교(n)

- 재귀식으로 하는 경우가 많음

---

## 퀵 정렬

기준 아이템(pivot item) 중심으로 분할하고 각각을 정렬 (병합 처리 불필요)

- 평균 시간복잡도 : O(n log n)

- Partitioning
  
  1. 작업 영역을 정함
  
  2. 작업영역 중 가장 왼쪽에 있는 수를 Pivot이라고 하자 (그게 기준)
  
  3. Pivot을 기준으로 왼쪽에는 Pivot보다 작은 수 배치
     
     오른쪽에는 Pivot보다 큰 수 배치 (정렬 안됨)

- **<mark>Hoare-Partition 알고리즘</mark>**
  
  - P값들보다 큰 값은 오른쪽 집합, 작은 값들은 왼쪽 집합에 위치하도록 함
  
  - 피봇을 두 집합의 가운데에 위치시킴
  
  - 피봇 선택
    
    - 왼쪽 끝 / 오른쪽 끝 / 임의의 세개 값 중에 중간 값

- Lomuto partition 알고리즘
  
  - Hoare보다 **느리다**
  
  - 잘 쓰이지 않으니 참고만

---

## 이진 검색

자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정는 방법

- 목적 키를 찾을 때까지 이진 검색을 함으로써 검색 범위 반으로 줄여나가 빠름

- **<mark>이진 검색을 하기 위해서는 자료가 정렬된 상태여야 함</mark>**

- 검색 과정
  
  1. 자료의 중앙에 있는 원소를 고름
  
  2. 중앙 원소의 값과 찾고자 하는 목표 값 비교
  
  3. 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해 새로 검색,
     
     크다면 자료의 오른쪽 반에 대해서 새로 검색을 수행
  
  4. 찾고자 하는 값을 찾을 때까지 1~3의 과정을 반복

- 반복구조
  
  ![image](https://github.com/user-attachments/assets/6336365f-dc62-4aee-b769-a490eb69d8df)

- 재귀구조
  
  ![image](https://github.com/user-attachments/assets/751ebcde-e586-463d-8c72-4db4317dc404)
