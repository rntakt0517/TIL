# start_2

[비트 연산](#비트-연산)

[실수](#실수)

---

## 비트 연산

- 정의
  
  - 1 bit : 0과 1을 표현하는 정보의 단위
  
  - 1 Byte : 8 bit를 묶어 1 Byte라고 함

- 비트연산
  
  - 컴퓨터의 CPU는 0과 1로 다루어 동작되며, 내부적으로 비트 연산을 사용하여 덧셈, 뺄셈, 곱셈 등을 계산
  
  - 더 나아가, 프로그래밍에서 비트연산을 활용한 코딩 방법을 익혀보기

- 비트 연산자
  
  - `&` : a AND b, 둘 다 1 일때만 결과가 1. 그 외에는 0
  
  - `|` : a OR b, a, b 둘 중 하나만 1이면 결과가 1. 그 외에는 0
  
  - `^` : XOR, 같으면 0 다르면 1 (어떤 값이던 특정 수로 2회하면 원래 수로 돌아옴)
  
  - `<<` : Left Shift, 특정 수 만큼 비트를 왼쪽으로 밀어냄 (0이 뒤에 붙음)
  
  > 재귀없이 <mark>**부분집합**</mark> (i & (1 << N) : N번째 비트가 1인지 아닌지 확인)
  > 
  > ```python
  > # i 의미 : i번째 부분집합
  > for i in range(1 << len(arr)):
  >     for idx in range(len(arr)):
  >         # i & (1 << idx)
  >         # -i번째 부분집합에 idx 요소가 포함되어 있나요?
  >         if i & (1 << idx):
  >             print(arr[idx], end='')
  >     print()
  > ```
  
  - `>>` : Right Shift, 특정 수 만큼 비트를 오른쪽으로 밀어냄 (우측 비트들은 제거됨)

- **<mark>진수 변환</mark>**
  
  - 10진수 -> 2, 16진수 변환
    
    ```python
    print(bin(10))    # 0b1-1-
    print(hex(10))    # 0xa
    ```
  
  - 2, 16진수 -> 10진수 변환
    
    ```python
    print(int('1011', 2))    # 11
    print(int('b', 16))      # 11
    ```

- 음수 표현 방법 : 2의 보수
  
  1. 수를 모두 뒤집고 +1
  
  2. 음수 양수 더했을 때 추가로 생기는 비트는 버림
  
  > 2의 보수를 2번 하면 원래의 값으로 돌아옴
  
  - `~` : NOT, 모든 비트를 반전시킴

---

## 실수

- 소수점 출력 방법
  
  - `{N:.2f}` : N 값을 소수점 둘째자리**에서** 반올림하여 표현
  
  > 비트로 표현하면 무한 반복되는 숫자끼리 더하기 때문에 오차 발생
  > 
  > - True : 오차가 허용범위 안
  > 
  > - False : 오차가 허용범위 밖

- 최대 : `float('inf')`

- 최소 : `float('-inf')`

- 소수점이 있는 10진수 -> 2진수 (반대는 1/2의 제곱씩 알아서 잘)
  
  1. 곱하기 2
  
  2. 1의 자리에 숫자 생기면 1, 아니면 0
  
  3. 반복

- <mark>**부동 소수점 표기법**</mark>
  
  - IEEE  754라는 컴퓨터에서 부동소수점을 표기하는 구제표준
  
  - 소수점의 위치를 고정시켜 표현
  
  - 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현
    
    ex) 1001.001 -> 1.0010011 x 2**3
    
    - 가수는 100011이고, 지수는 3 (맨 앞 1은 생략)
    
    > bias(바이어스 표시법) : 지수에 127 더하기
    > 
    > 그러면 지수는 130 = 10000010이 됨
